from typing import Dict

import gym
import numpy as np
from gym import spaces

from quadruped_gym.quadruped.a1_pybullet import A1PyBulletRobot


def _flatten_observation_space(observation_space: spaces.Dict):
    assert isinstance(observation_space, spaces.Dict)

    lower_bound = []
    upper_bound = []
    for _, value in observation_space.spaces.items():
        lower_bound.append(np.asarray(value.low).flatten())
        upper_bound.append(np.asarray(value.high).flatten())
    lower_bound = np.concatenate(lower_bound)
    upper_bound = np.concatenate(upper_bound)
    flat_observation_space = spaces.Box(np.array(lower_bound), np.array(upper_bound), dtype=np.float64)
    return flat_observation_space


def _flatten_observation(observation: Dict[str, np.ndarray]):
    """Flattens the observation dictionary to an array.

    Args:
      observation_dict: A dictionary of all the observations.

    Returns:
      An array of all the observations
    """
    flat_observation = []
    for _, value in observation.items():
        flat_observation.append(np.array(value).flatten())
    flat_observation = np.concatenate(flat_observation)
    return flat_observation


class AddPoseOffsetWrapper(gym.ActionWrapper):
    """Adds the A1 robot default pose to the action"""

    def action(self, action: np.ndarray):
        return np.array(A1PyBulletRobot.INIT_MOTOR_ANGLES) + action


class ActionLimitWrapper(gym.ActionWrapper):
    """Applies an additional limit to the actions generated by the NN"""

    def __init__(self, env: gym.Env, action_limit: np.ndarray):
        super(ActionLimitWrapper, self).__init__(env)
        self.action_space = spaces.Box(-action_limit, action_limit, dtype=action_limit.dtype)

    def action(self, action: np.ndarray):
        # TODO: maybe clipping / projection into the wrapped env's action space?
        return action


class ObservationDictionaryToArrayWrapper(gym.ObservationWrapper):
    """Flattens a (non-nested) observation dictionary to an array"""

    def __init__(self, env: gym.Env):
        super(ObservationDictionaryToArrayWrapper, self).__init__(env)
        self.observation_space = _flatten_observation_space(env.observation_space)

    def observation(self, obs: Dict[str, np.ndarray]):
        return _flatten_observation(obs)
